#include <iostream> 
#include <windows.h> //включает функции WinAPI 
#include <conio.h> //библиотека для создания текстового интерфейса пользователя
#include "Header.h"
#include <vector> //подключаем библиотеку для работы с	vector
#include <algorithm> //подключаем библиотеку для работы с алгоритмами

using namespace std;


//функция выстрела, определения уничтожения кораблкиков и определение победителя в игре
//изменяет mask_pos - для отображения результатов выстрела
//возвращает результаты выстрела (промах, раненеие корабля, корабль уничтожен)
int explosion(int mask_pos[12][24], int ship_pos[12][24], int y, int x, Ship* ships, bool& end_game)
{
	int i=0,result=0;
	int A = 0; //переменная для правильной зарисовки границы вокруг взоравнного кораблика
	int B = 13; //переменная, которая будет помогать указывать на нужный кораблик
	int C = 0; //переменная, которая хранит количество уничтоженных корабликов (если = 10, то игра завершается)
	bool alive = false; //переменная с помощью которой мы будем проверять уничтожение корабликов/	
	//переменная для определения смещения по x offset
	
	
	if (mask_pos[y - 1][x]==-3)
		return 3;
	
	if (ship_pos[y - 1][x] < 1) //Если на позиции по которой был произведён огонь ничего нету
	{
		result = 0;
		for (; i < 2; i++) 
		{
			//если это так то мы заменяем в клеточке номер на "-2"
			ship_pos[y - 1][x + i] = -2; // изменяем значение
			mask_pos[y - 1][x + i] = -2;
			result = 0;
		}
	}
	else if (ship_pos[y - 1][x ] >= 1)
	{
		if (ships[ship_pos[y - 1][x]].live > 1) //если кораблик не уничтожен
		{
			result = 1;
			ships[ship_pos[y - 1][x]].live--; //уменьшаем жизнь кораблика на 1
			ship_pos[y - 1][x + i] = -3;
			mask_pos[y - 1][x + i] = -3;
		}
		else if (ships[ship_pos[y - 1][x]].live == 1)
		{
			result = 2;
			ships[ship_pos[y - 1][x]].live--; //уменьшаем жизнь кораблика до 0
		}
		//заменяем в клеточке номерок кораблика на "-3"
		for (int i = 0; i < 2; i++)
		{
			ship_pos[y - 1][x  + i] = -3;
			mask_pos[y - 1][x  + i] = -3;
		}
		// Проставляем оккупацию корабля если подбит
		//mask_pos[y - 1][x - 35];
		//меняем значение переменной A для правильной отрисовки
		//для 4-х палубных
		if (ships[ship_pos[y - 1][x ]].deck == 4) A = 0;
		//для 3-х палубных
		else if (ships[ship_pos[y - 1][x]].deck == 3) A = 1;
		//для 2-х палубных
		else if (ships[ship_pos[y - 1][x]].deck == 2) A = 2;
		//для 1-о палубных
		else A = 3;

		//если он имеет горизонтальное положение
		if (ships[ship_pos[y - 1][x]].horizontal == true)
		{
			for (int q = 0; q < 3; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо окупировать корабли чтобы они не стояли вполтную к друг другу
			{
				for (int w = 0; w < ships[ship_pos[y - 1][x]].deck * 3 + A; w++) //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы "окупировать" уничтоженный кораблик
				{
					mask_pos[ships[ship_pos[y - 1][x]].y - 2 + q][ships[ship_pos[y - 1][x]].x - 4 + w] = -1; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "2" (промах)
				}
			}
			for (int g = 0; g < 2 * ships[i].deck; g++) //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы выделить уничтоженный кораблик
			{
					mask_pos[ships[ship_pos[y - 1][x]].y - 1][ships[ship_pos[y - 1][x]].x - 2 + g] = -1; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "3" (поподание)
			}
		}
		else if (ships[i].horizontal == false)  //если он имеет вертикальное положение
		{
			for (int q = 0; q < ships[ship_pos[y - 1][x]].deck + 2; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
			{
				for (int w = -4; w < 2; w++)  //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы "окупировать" уничтоженный кораблик
				{
					mask_pos[ships[ship_pos[y - 1][x]].y - 2 + q][ships[ship_pos[y - 1][x]].x + w] = -1; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "2" (промах)
				}
			}

			for (int g = 0; g < ships[ship_pos[y - 1][x]].deck; g++) //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы выделить уничтоженный кораблик
			{
				for (int n = -2; n < 0; n++) //выполняем нижеуказаныый код 2 раза так как нам нужно поменять значения в массиве для 2-ух клеточек (одной палубы)
				{
					mask_pos[ships[ship_pos[y - 1][x]].y - 1 + g][ships[ship_pos[y - 1][x]].x + n] = -1; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "3" (поподание)
				}
			}
		}
	}

	//Проверяем жизни кораблей
	for (int i = 1; i < count_ship+1; i++) //перебираем все корабли
	{
		if (ships[i].live == 0) //если жизни корабля = 0
			C++;
	}

	if (C == count_ship) //если все наши кораблики уничтожены
		end_game=true; //завершаем игру победа
	else //иначе
		end_game = false ; //игра продолжается не все корабли уничтожены
	
	//результат проверки на уничтожение корабля 
	// return 0 - промах
	// return 1 - корабль ранен
	// return 2 - корабль уничтожен
	// return 3 - клетки с уже подбитыми кораблями (нужны для организации стрельбы компьютера в режиме AI)
	return result;
		
}

//присвоение палуб в соответствии с номером кораблика
// присвоение жизней в соответствии с номером кораблика
void LoadCharactShips(Ship* ships)
{
	for (int i = 1; i < count_ship+1; i++)
	{
		//делаем кораблики с 1-ой палубой
		if (i>=1 && i<=4) 
		{
			ships[i].deck = 1;
			ships[i].live = 1;
		}
		//делаем кораблики с 2-мя
		else if (i >= 5 && i <= 7)
		{
			ships[i].deck = 2;
			ships[i].live = 2;
		}
		//делаем кораблики с 3-мя палубами
		else if (i == 8 || i == 9)
		{
			ships[i].deck = 3;
			ships[i].live = 3;
		}
		//делаем кораблик с 4-мя палубами
		else if (i == 10) 
		{
			ships[i].deck = 4;
			ships[i].live = 4;
		}
	}
}

//прорисовка игровой карты в соответсвии с положением поставленных корабликов
void PaintPos(int mas[_size+2][_size * 2 + 4], int x, int num_color, bool flag_show = false)
{
	for (int i = 1; i < _size + 1; i++)
	{
		int y = 1 + i; //уставнавливаем координаты по умолчанию 2 по Х и 2 по Y так как отрисовка поля должно начинаться там
		SetCursor(x, y); //перемещаем курсор на вышеуказанные позиции

		//выполнеям нижеуказанный код 20 раз так как общее количество столбцов равно 20
		// _size - размер поля (по умолчанию 10)
		for (int g = 2; g < _size * 2 + 2; g++)
		{
			if (mas[i][g] == -2) //если в массиве на этом месте находится "-2" 
			{
				setColor(LightGray, LightGray); //рисуем серую клеточку
			}
			else if (mas[i][g] == -1) //если в массиве на этом месте находится "-1"
			{
				setColor(LightMagenta, LightMagenta); //рисуем клеточку пурпурного цвета
			}
			else if (mas[i][g] == -3) //если в массиве на этом месте находился корабль "-3"
			{
				setColor(Color(num_color), Color(num_color)); //устанавливаем цвет корабликов (наши - синие / врага - красные)
			}
			else if (flag_show && ship_pos[i][g] >= 1) //если в массиве на этом месте находился корабль "-3"
			{
				setColor(Color(num_color), Color(num_color)); //устанавливаем цвет корабликов (наши - синие / врага - красные)
			}
			else //в иных случаях рисуем белую клеточку
			{
				setColor(White, White); //устанавливаем белый цвет так как таким цветом будет игровая локация на которой будут происходить основные действия
			}
			cout << "+"; //рисуем любой знак, из-за окраски он будет квадратиком
		}
		cout << "\n"; //переход на новую строку при отрисовки одной строки полностью
	}
}

//для отладки прорисовка игровой карты в соответсвии с положением поставленных корабликов
void PaintPos2(int mas[_size + 2][_size * 2 + 4], int x, int num_color, int _ship_pos[_size + 2][_size * 2 + 4], bool flag_show = false)
{
	for (int i = 1; i < _size + 1; i++)
	{
		int y = 1 + i; //уставнавливаем координаты по умолчанию 2 по Х и 2 по Y так как отрисовка поля должно начинаться там
		SetCursor(x, y); //перемещаем курсор на вышеуказанные позиции

		//выполнеям нижеуказанный код 20 раз так как общее количество столбцов равно 20
		// _size - размер поля (по умолчанию 10)
		for (int g = 2; g < _size * 2 + 2; g++)
		{
			if (mas[i][g] == -2) //если в массиве на этом месте находится "-2" 
			{
				setColor(LightGray, LightGray); //рисуем серую клеточку
			}
			else if (mas[i][g] == -1) //если в массиве на этом месте находится "-1"
			{
				setColor(LightMagenta, LightMagenta); //рисуем клеточку пурпурного цвета
			}
			else if (mas[i][g] == -3) //если в массиве на этом месте находился корабль "-3"
			{
				setColor(Color(num_color), Color(num_color)); //устанавливаем цвет корабликов (наши - синие / врага - красные)
			}
			else if (flag_show && _ship_pos[i][g] >= 1) //если в массиве на этом месте находился корабль "-3"
			{
				setColor(Color(num_color), Color(num_color)); //устанавливаем цвет корабликов (наши - синие / врага - красные)
			}
			else //в иных случаях рисуем белую клеточку
			{
				setColor(White, White); //устанавливаем белый цвет так как таким цветом будет игровая локация на которой будут происходить основные действия
			}
			cout << "+"; //рисуем любой знак, из-за окраски он будет квадратиком
		}
		cout << "\n"; //переход на новую строку при отрисовки одной строки полностью
	}
}

//Функция для отрисовки игрового поля. параметр speed - скорость отрисовки.
void CreatField(int speed, int X, int num_color)
{
	SetCursor(X, 1); //Устанавливаем курсор на нужную позицию
	char mas[10] = { 'А','Б','В','Г','Д','Е','Ж','З','И','К' }; //буковки которые будут находится сверху игрового поля и ориентировать игрока куда он бьёт
	setColor(White, Color(num_color)); //Смена цвета (буква - белый; заливка - красный/синий)
	int A = 0, B = 0; //переменные необходимые для правильной отрисовки игрового поля
	cout << "  " << mas[0]; //С помощью этого печатаем букву "А"и ставим в начале пробел чтобы было ровненько и красиво
	for (int i = 0; i < _size + 2; i++) //выполнеям нижеуказанный код 12 раз так как общее количество строк равно 12
	{
		if (B == 0)
		{
			SetCursor(X + 3, 1 + i); //Устанавливаем курсор на нужную позицию
			B++; //увеличиваем значение переменной
		}
		else //иначе
		{
			SetCursor(X, 1 + i);  //Устанавливаем курсор на нужную позицию
		}
		for (int g = 0; g < _size * 2 + 3; g++) //выполнеям нижеуказанный код 23 раз так как общее количество столбцов равно 23
		{
			if (i == 0 && g == _size * 2 + 2) //выполняем нижеуказанный код, если мы на первой строке, и 22 элементе
			{
				setColor(Color(num_color), Color(num_color)); //Меняем цвет текста и заливки на красный/синий (границы поля на которых нету цифр ил букв)
				Sleep(speed); //Задержка чтобы была анимация
				cout << '+'; //рисуем любой знак, из-за окраски он будет квадратиком
			}
			if (i == 0 && g > 0 && g < _size) //выполняем ниэеуказанный код, если мы на первой строке, и в диапозоне с 0-го по 10-ый элемент
			{
				setColor(White, Color(num_color)); //Смена цвета (буква - белый; заливка - красный/синий)
				Sleep(speed); //Задержка чтобы была анимация
				cout << " " << mas[g];
			}
			else if (i > 0 && i < _size + 1 && g == 0) //Иначе если мы находимся с 1-ой по 11-ую строку на 0-м элементе
			{
				setColor(White, Color(num_color)); //Смена цвета (буква - белый; заливка - красный/синий)
				if (i < _size) //Если мы находимся на строках не достигающих значения "10"
				{
					Sleep(speed); //Задержка чтобы была анимация
					cout << i << ' '; //Пишим цифру указывающая на номер строки которая будет помагать игроку ориентироваться куда он стреляет () для того чтобы было ровно по соотношению с двузначными цифрами
				}
				else //иначе
				{
					Sleep(speed); //Задержка чтобы была анимация
					cout << i; //Пишем цифру без пробелов так как тут они не будут нужны ведь цифра которая будет выводиться "10"
				}
			}
			else if (i == 11 || g > _size * 2 && g < _size * 2 + 3) //Иначе если мы находимся на 11-ой строке, на 21-22-ых элементах
			{
				if (A == 0 && i == _size + 1) //проверка на последней строке которая нужна чтобы выводился кубик
				{
					Sleep(speed); //Задержка чтобы была анимация
					cout << "+";//рисуем любой знак, из-за окраски он будет квадратиком
					A++; //меняем значение переменной благодаря которой было можно реализовать дорисовку нужного кубика
				}
				setColor(Color(num_color), Color(num_color)); //Меняем цвет текста и заливки на красный/синий (границы поля на которых нету цифр ил букв)
				Sleep(speed); //Задержка чтобы была анимация
				cout << '+'; //рисуем любой знак, из-за окраски он будет квадратиком
			}
			else if (i > 0) //если мы находимся на строке номер которой не равен "0" (непосредственно игровое поле)
			{
				Sleep(speed); //Задержка чтобы была анимация
				setColor(White, White); //Меняем цвет текста и заливки на белый (непосредственно игровое поле)
				cout << '+'; //рисуем любой знак, из-за окраски он будет квадратиком
			}
		}
	}
	setColor(Black, Black); //устанавливаем полностью черный цвет
}

//aвтоматическая расстановка корабликов
void auto_arrangement(Ship* Ships, int ship_pos[_size + 2][_size * 2 + 4])
{
	//переменная для координат и индекса корабля
	int y, x, index = 1;
	while (index < count_ship + 1) //выполняем нижеуказанный код до тех пор пока, не будут расставлены все 10 корабликов
	{
		//присваиваем рандомную ориентацию
		Ships[index].horizontal = rand() % 2;
		//присваиваем рандомные координаты (в рамках игровой зоны)
		x = (rand() % 11 + 1) * 2;
		y = rand() % _size + 1;

		//проверяем заденит ли кораблик границу по вертикале, если его не отодвинуть
		if (Ships[index].horizontal == false && y + Ships[index].deck - 1 >= _size + 2)

		{
			//если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
			y -= y + Ships[index].deck ;
		}
		//проверяем заденит ли кораблик границу по горизонтали, если его не отодвинуть
		else if (Ships[index].horizontal == true && x + (Ships[index].deck - 1) * 2 >= _size * 2 + 4)
		{
			//если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
			x -= x + Ships[index].deck * 2 +2;
		}
		// проверяем имеет ли кораблик горизонтальное положение и нет ли ничего на позициях куда он будет устанавливаться
		if (Ships[index].horizontal == true && ship_pos[y][x] == 0 && ship_pos[y][x + Ships[index].deck * 2 - 2] == 0)
		{
			//запоминаем координаты первой палубы у каждого кораблика, чтобы в дальнейшем правильно их взрывать и поменять клетки вокруг
			Ships[index].x = x + 2, Ships[index].y = y;
			for (int q = 0; q < 3; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо "окупировать" кораблик чтобы они не стояли вполтную к друг другу
			{
				for (int w = 1; w < Ships[index].deck * 3 + 1; w++)//выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы "окупировать" уничтоженный кораблик
				{
					ship_pos[y - 2 + q][x - 3 + w] = -1;  //меняем значение "окупируемых" позиций в двумерном массиве на "1" (окупируемая позиция живого кораблика)
				}
			}
			//выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы выделить кораблик
			for (int g = 0; g < 2 * Ships[index].deck; g++)
			{
				//меняем значение позиций в двумерном массиве который будем проверять на различные цифорки, на "1-10" (номера корабликов (у каждого свой))
				ship_pos[y][x + g] = index;
			}
			index++; //переходим к следующему кораблику
		}

		// проверяем имеет ли кораблик вертикальное положение и нет ли ничего на позициях куда он будет устанавливаться
		if (Ships[index].horizontal == false && ship_pos[y][x] == 0 && ship_pos[y + Ships[index].deck - 2][x] == 0)
		{
			//запоминаем координаты первой палубы у каждого кораблика, чтобы в дальнейшем правильно их взрывать
			Ships[index].x = x + 2, Ships[index].y = y;
			for (int q = 0; q < Ships[index].deck + 2; q++)
			{
				for (int w = 0; w < 6; w++)
				{
					//меняем значение "окупируемых" позиций в двумерном массиве который будем проверять на различные цифры, 
					// на "1" (окупируемая позиция живого кораблика)
					ship_pos[y - 1 + q][x - 2 + w] = -1;
				}
			}
			for (int g = 0; g < Ships[index].deck; g++)
			{
				//выполняем нижеуказаныый код 2 раза так как нам нужно поменять занчения в массиве для 2-ух клеточек (одной палубы)
				for (int n = 0; n < 2; n++)
				{
					//меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "4-13" (номера корабликов (у каждого свой))
					ship_pos[y - 1 + g][x + n] = count_ship + 1 - index;
				}
			}
			index++;
		}
	}
}


//ручная расстановка корабликов
void manual_arrangement(Ship* Ships, int ship_pos[_size + 2][_size * 2 + 4]) {
	//запускаем цикл в котором при нажатии на ту или иную клавишу 
	// будем делать различные действия в зависимости от нажатой клавиши
	int num = 1, key;
	int x=2, y=2;	
	do 
	{
		//перерисовываем игровую локацию с учетём внесенных изменений (поставили кораблик)
		PaintPos(ship_pos, 2, 0); 
		SetCursor(x, y); //ставим курсор на позицию изменяемых ниже переменных (X, Y)
		setColor(Black, Black); //устанавливаем черный цвет так как таким цветом будет выводиться кораблик
		if (Ships[num].horizontal == true) //если кораблик имеет горизонтальное положение
		{
			for (int i = 0; i < Ships[num].deck; i++) //запускаем цикл который будет отрисовывать кораблик с нужным колличеством палуб
			{
				cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
			}
		}
		else if (Ships[num].horizontal == false)
		{
			y += Ships[num].deck; //изменяем позицию по "y" на то сколько палуб у кораблика
			for (int i = 0; i < Ships[num].deck; i++)  //запускаем цикл который будет отрисовыввать кораблик с нужным колличеством палуб
			{
				cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
				y--; //спускаемся вниз на одну клеточку
				SetCursor(x, y); //устанавливаем позицию на одну клеточку ниже и на изначальное по Х
			}
		}
		key = _getch();//функция возвращает номер нажатой клавиши
		switch (key) //Выполняем различные функции в соответствии с нажатой клавишью
		{
		case Left: //если нажали "Стрелочка влево"
			if (x > 2) //позиция до которой разрешено перемещение в лево
					x -= 2; //меняем значение по Х на -2 так как одна клеточка в игре равна двум в консоли
			break;
		case Right: //если нажали "Стрелочка вправо"
			if (Ships[num].horizontal == true) //Если кораблик имеет горизонтальное положение
			{
				if (x < _size * 2 + 2 - Ships[num].deck * 2) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
			}
			else  //Если кораблик имеет вертикальное положение
			{
				if (x < _size * 2 + 2) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
			}
			break;
		case Up: //если нажали "Стрелочка вверх"
			if (y > 2) //позиция до которой разрешено перемещение вверх
				y--;  //меняем значение по Y на -1
			break;
		case Down: //если нажали "Стрелочка вних"
			if (Ships[num].horizontal == false) //Если кораблик имеет вертикальное положение
			{
				if (y < _size + 2 - Ships[num].deck) // проверяем не достиг ли он позиции до которой ему можно передвигаться 
					//									(так как он n-палубный, и его нужно ограничивать на n клеточек ранее)
					y++;  //меняем значение по Y на +1
			}
			else
			{
				// проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
				if (y < _size +1)
				{
					y++;  //меняем значение по Y на +1
				}
			}
			break;
		case Space: //если нажали "Q" изменение положения корабля
			//изменяем ориентацию кораблика на противоположную
			Ships[num].horizontal = !Ships[num].horizontal; 
			//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
			if (Ships[num].horizontal == false && y + Ships[num].deck >= _size+3)
				//если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
				y -= y + Ships[num].deck - (_size+2);
			
			//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
			else if (Ships[num].horizontal == true && x + Ships[num].deck * 2 >= _size*2+4)
				//если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по горизонтали
				x -= (x + Ships[num].deck * 2) - (_size * 2 + 2);
			
			// заранее изменяем положение следующих корабликов на то которое мы выбрали сейчас
			for (int i = 0; i < _size - num; i++)
				Ships[num + i].horizontal = Ships[num].horizontal; 
			break; 
		case Enter: //если нажали "Enter"
			if (Ships[num].horizontal == true && ship_pos[y][x] == 0 && ship_pos[y][x + Ships[num].deck * 2 - 2] == 0)
			{
				//Ships[num].x = x + 2, Ships[num].y = y;
				for (int q = 0; q < 3; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
				{
					for (int w = 1; w < Ships[num].deck * 3 + 1; w++)   //так чтобы n-палубный кораблик полностью окупировался
																			 
					{
						ship_pos[y - 1 + q][x - 3 + w] = -1; //меняем значение окупируемых позиций в двумерном массиве который будем прверять на различные цифорки, на "-1"
					}
				}
				for (int g = 0; g < 2 * Ships[num].deck; g++) //выполнеям нижеуказанный код n-раз(кол-во палуб), одна палуба по горизонатали 2 клеточки
				{
					ship_pos[y][x + g] = _size+3 - num;  //меняем значение позиций в двумерном массиве на цифры кораблей
				}
			num++; //переходим к следующему кораблику
			}
			if (Ships[num].horizontal == false && ship_pos[y - 1][x] == 0 && ship_pos[y + Ships[num].deck - 2][x] == 0)
			{
				Ships[num].x = x + 2, Ships[num].y = y;
				for (int q = 0; q < Ships[num].deck + 2; q++) //выполнеям нижеуказанный код 6 раз так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
				{
					for (int w = 0; w < 6; w++) //выполнеям нижеуказанный код 6 раз так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
					{
						ship_pos[y - 1 + q][x - 2 + w] = -1; //меняем значение окупируемых позиций в двумерном массиве который будем прверять на различные цифорки, на "1"
					}
				}
				for (int g = 0; g < Ships[num].deck; g++) //выполнеям нижеуказанный код n-раз(кол-во палуб)
				{
					for (int n = 0; n < 2; n++) //выполняем нижеуказаныый код 2 раза так как нам нужно поменять занчения в массиве для 2-ух клеточек (одной палубы)
					{
						ship_pos[y - 1 + g][x + n] = _size - num; //меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "2"
					}
				}
			num++; //переходим к следующему кораблику	
			}
			break;
		case Esc:
			//Выход из ручной расстановки кораблей
			num = count_ship;
			break;
		}
		
		
		

	} while (num <= count_ship-1); //цикл работает до тех пор пока количество расставленных корабликов не станет равно 10
}

// Очистка позиций кораблей на поле боя
void clear_ship_pos(int ship_pos[_size + 2][_size * 2 + 4]) {
	for (int i = 0; i < _size + 2; i++) {
		for (int j = 0; j < _size * 2 + 4; j++) {
			ship_pos[i][j] = 0;
		}
	}
}





//показ меню 
void ShowItemMenu(char MenuItem[numItem][100], int numint, char ItemSubMenu[numSubItem][100],int numint2, int T, bool flagsubmenu = 0, int subT = -1)
{
	system("cls"); //очищаем консоль
	for (int i = 0; i < numint; i++) //создаём цикл для элементов меню
	{
		SetCursor(30, 6 + i); //Устанавливаем курсор на нужную позицию
			if (i == T)//проверка на выбранный пункт
			{
				setColor(Black, White); //выделяем выбранный пункт
			}
			else
			{
				setColor(White, Black); //убираем выделение выбранного пункта
			}
			
			cout << MenuItem[i]; //выводим пункт меню в виде текста
			
				// выводим пункты подменю в виде текста если выбран пункт меню у которого есть подменю
			if (i==1 && flagsubmenu) {
				
				//создаём цикл для элементов подменю	
				for (int j = 0; j < numint2; j++) {
					SetCursor(55, 6 + i+j);
					if (j == subT) //проверка на выбранный пункт
					{
						setColor(Black, White); //выделяем выбранный пункт
					}
					else //иначе
					{
						setColor(White, Black); //убираем выделение выбранного пункта
					}
					cout << " -> "<<ItemSubMenu[j]; //выводим пункты в виде тектса
			}
		}
	}
	//CreatField(0, 0, 9); //создаём игровое поле занаво
}
void Meny(int num)
{
	SetCursor(22, 15); //Устанавливаем курсор на нужную позицию
	setColor(Black, Black); //устанавливаем полностью черный цвет
	cout << "++++++++++++++++++++++++++++++++++++++++++"; //выводим "+", очищаем предыдущую реплику
	SetCursor(22, 15); //Устанавливаем курсор на нужную позицию
	if (num >= 0 && num <= 5) //проверяем, если реплики больше относятся к врагу
	{
		setColor(Red, Black); //Устанавливаем красный цвет текста на черном фоне 
	}
	else //иначе реплики больше относятся ко мне
	{
		setColor(Green, Black); //Устанавливаем зеленый цвет текста на черном фоне 
	}
	cout << variant[num];
	//выводим новую реплику

}

int main()
{
	setlocale(LC_ALL, ""); //Делаем возможным вывод в консоль на русском языке
	srand(time(NULL));

	

	//загрука характеристик корабликов для человека  (количество палуб)
	LoadCharactShips(ships);
	//загрука характеристик корабликов для компьютера  (количество палуб)
	LoadCharactShips(comp_ships);
	int key = 1, y = 2, x = 2, num = 0, Selitem = 0, Selsubitem = 0, A = 0, up = 0, down = 0;
	bool manual_placement = true, 
	
	//флаг для окончания игры компьютера (выиграл)	
	your_turn = rand() % 2, 
	start = false;
	
	

	
	//переменные для:
	/*
	key - переменная для записи нажатой клавиши
	start - переменная для проверки на начало боя
	speed - скорость прорисовки игрового поля
	А - дополнительная переменная для меню
	SN - переменная для того чтобы запоминать какой кораблки мы стараемся добить.
	up - переменная которая поможет правильно добивать наши кораблики
	down - переменная которая поможет правильно добивать наши кораблики
	xx - дополнительная перемнная для записи положения курсора на вражеском поле
	yy - дополнительная перемнная для записи положения курсора на вражеском поле
	y - позиция по Y
	x - позиция по X
	change - номер расстановки который будет использован
	num - номер кораблкиа
	manual_placement - тип расстановки который будет использован
	mode_comp - режим стрельбы компьютера (0 - случайные координаты; 1 - умный режим если есть попадание по палубе)
	dirs - направление стрельбы компьютера в режиме AI
	*/





	Avake(); //Вывыдим надпись "МОРСКОЙ БОЙ" на экран
	Sleep(1500); //ждём 1.5 секунды
	setColor(White, Black); //Устанавливаем цвет текста (белый на голубом)
	system("cls"); //очищяем консоль

	
	

	ShowItemMenu(MenuItem, numItem, MenuSubItem, numSubItem, Selitem);
	bool flag_exit = true;
	bool flagshowsubitemmenu = false;
	bool flag_placement = false;
	do //запускаем цикл
	{
		key = _getch(); //получаем номер нажатой клавиши
		switch (key) //запускаем свитч
		{
		case Up: //если нажали "Стрелочка вверх"
			if (Selitem > 0 && !flagshowsubitemmenu) Selitem--;
			if (Selsubitem > 0 && flagshowsubitemmenu) Selsubitem--;
			ShowItemMenu(MenuItem, numItem, MenuSubItem, numSubItem, Selitem, flagshowsubitemmenu, Selsubitem); //вывод пунктов на экран
			break;
		case Down: //если нажали "Стрелочка вниз"
			if (Selitem < numItem - 1 && !flagshowsubitemmenu) Selitem++;
			if (Selsubitem < numSubItem - 1 && flagshowsubitemmenu) Selsubitem++;
			ShowItemMenu(MenuItem, numItem, MenuSubItem, numSubItem, Selitem, flagshowsubitemmenu, Selsubitem); //вывод пунктов на экран
			break;
		case Enter:
			switch (Selitem)
			{
			case Start:
				if (flag_placement == false) {
					//автоматическая расстановка для своих корабликов, если не выбирались пункты меню "расстановки кораблей"
					auto_arrangement(ships, ship_pos);
				}
				//автоматическая расстановка для кораблей компьютера
				auto_arrangement(comp_ships, comp_ship_pos);
				flag_exit = false;
				break;
			case OptionsShipRelated:
				//начинаем показывать подменю
				if (Selitem == OptionsShipRelated && !flagshowsubitemmenu) 
				{
					flagshowsubitemmenu = !flagshowsubitemmenu;
					ShowItemMenu(MenuItem, numItem, MenuSubItem, numSubItem, Selitem, flagshowsubitemmenu, Selsubitem);
					break;
				}
				// если подменю показано и выбран пункт автоматическая расстановка
				if (Selitem == OptionsShipRelated && Selsubitem == Auto)
				{
					manual_placement = false;
					//очистка поля игрока если что-то есть
					clear_ship_pos(ship_pos);
					// автоматическая расстановка кораблей для игрока
					auto_arrangement(ships, ship_pos);
					//создаем поле игрока
					CreatField(0, 0, 9);
					//отрисовка поля игрока
					PaintPos(ship_pos, 2, 0);
					flag_placement = true;
				}
				// подменю показано и выбран пункт ручная расстановка
				if (Selitem == OptionsShipRelated && Selsubitem == Manual)
				{
					//ручная расстановка кораблей игрока
					manual_placement = true;
					//очистка поля игрока если что-то есть
					clear_ship_pos(ship_pos);
					//создаем поле игрока
					CreatField(0, 0, 9);
					//отрисовка поля игрока
					PaintPos(ship_pos, 2, 0);
					manual_arrangement(ships, ship_pos);
					flag_placement = true;
				}
			case Tournament:
				//показываем файл с наименованиями игроков и результатами, по аналогии с крестиками/ноликами
				break;
			case EXIT:
				return 1;
				break;
			}
			break;

		case Esc:
			if (Selitem == OptionsShipRelated && flagshowsubitemmenu) {
				flagshowsubitemmenu = !flagshowsubitemmenu;
				ShowItemMenu(MenuItem, numItem, MenuSubItem, numSubItem, Selitem, flagshowsubitemmenu, Selsubitem);
			}

			break;


		}
	} while (flag_exit);


	system("cls"); //очищяем консоль
	
	

	Sleep(20);
	//создаем поле игрока
	CreatField(0, 0, LightBlue);
	
	//создаём игровое поле компьютера
	CreatField(0, 35, Red);

	

	int FirstHitX = 0;
	int FirstHitY = 0;
	int xComp = 0;
	int yComp = 0;
	//флаг для окончания игры человека/компьютера (выиграл)
	bool win_comp = false;
	bool win_human = false;
	
	// направление для стрельбы в режиме AI
	int dir;
	//заполнение вектора направлений для стрельбы компьютера в режиме AI
	dirs.push_back(3);
	dirs.push_back(2);
	dirs.push_back(1);
	dirs.push_back(0);
	
	//перемешиваем случайным образом направления в векторе
	random_shuffle(dirs.begin(), dirs.end());
	
	//устанавливаем режим стрельбы компьтера первоночально - случайный
	int mode_comp = 0;
	
	// результата выстрела
	int result_shot;
	/* 
	0 - промах;
	1 - ранен;
	2 - убит
	*/

	// начальные координаты для отрисовки поля компьютера
	x = 37;
	y = 2;

	do
	{
		//перерисовываем игровую локации с учетём внесенных изменений (поставили кораблик)
		//отрисовка поля игрока, показ где находятся корабли
		PaintPos(mask_pos, 2, Red, true);
		//отрисовка поля компьютера
		PaintPos(comp_mask_pos, 37, Green);
		//для отладки - PaintPos2(comp_mask_pos, 37, LightBlue,comp_ship_pos,true); // у компьютера без показа кораблей 
		
		if (your_turn == true) //если моя очередь атаковать
		{
			do //запускаем цикл в котором при нажатии на ту или иную клавишу будеи делать то или иное дейстивие
			{
				// для отладки PaintPos2(comp_mask_pos, 37, LightBlue, comp_ship_pos, true);  
				PaintPos(comp_mask_pos, 37, Green);
				setColor(LightCyan, LightCyan); //устанавливаем серый цвет чтобы выделить активную ячейку
				SetCursor(x, y); //ставим курсор на позицию изменяемых ниже переменных (X, Y)
				cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
				key = _getch();//функция возвращает номер нажатой клавиши
				switch (key) //Выполняем различные функции в соответствии с нажатой клавишью
				{
				case Left: //если нажали "Стрелочка влево"
					if (x > 37) //позиция до которой разрешено перемещение в лево					
						x -= 2; //меняем значение по Х на -2 так как одна клеточка в игре равна двум в консоли					
				break;
				case Right: //если нажали "Стрелочка вправо"
					if (x < 55) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
				break; 
				case Up: //если нажали "Стрелочка вверх"
					if (y > 2) //позиция до которой разрешено перемещение вверх
						y--;  //меняем значение по Y на -1
				break; 
				case Down: //если нажали "Стрелочка вних"
					if (y < 11) //позиция до которой разрешено перемещение вниз
						y++;  //меняем значение по Y на +1
				break;
				case Enter:
					result_shot = explosion(comp_mask_pos, comp_ship_pos, y, x-35, comp_ships, win_human);
					if (win_human) break;
					if (result_shot == 2)
					{
						Meny(you_ship_explosion);
						Sleep(500); //небольшая пауза
					}
					else if (result_shot == 1) 
					{ 
						Meny(you_hit_move);
						Sleep(500); //небольшая пауза
					}
					else if (result_shot == 0) 
					{
						Meny(you_missed); 
						Sleep(500); //небольшая пауза
						//вывод - очередь атаки противника
						Meny(Comp_move);
						your_turn = !your_turn;
					}
				break;
				}
			} while (key != Enter);
		}
		//если ход противника
		if (your_turn == false)
		{
			//выбор случайных координат
			if (mode_comp == 0)
			{
				//небольшая пауза
				Sleep(0 + rand() % 400);
				//вывод реплику на экран
				Meny(Comp_think);
				//перерисовываем наше поле
				//PaintPos(ship_pos, 2, 0);
				//небольшая пауза
				Sleep(0 + rand() % 400);

				//случайным образом выдаём кооординату по котороой будет происходить атака
				//не стреляем в клетки куда уже были выстрелы, по периметру подбитых кораблей 
				do
				{
					xComp = (rand() % 11)*2 +2;
					yComp = rand() % 11 +1;
				} while (mask_pos[yComp][xComp] != 0);
				//проверяем позицию по которой мы выстрельнули на наличие корабликов
				result_shot = explosion(mask_pos,ship_pos, yComp, xComp, ships, win_comp);

				//проверяем на уничтожение
				if (win_comp) break;
				if (result_shot == 0)
				{
					Sleep(500); //небольшая пауза
					//вывод промаха на экран
					Meny(Comp_missed);
					Sleep(500);
					//очередь атаки противника
					Meny(you_move);
					your_turn = !your_turn;
				}
				else if (result_shot == 2)
				{
					// Вывод попадания/ранения на экран
					Meny(Comp_ship_explosion);
					Sleep(500); //небольшая пауза
				}
				else if (result_shot == 1)
				{
					//меняем режим стрельбы на AI
					mode_comp = 1;
					// Запоминаем координаты попадания
					FirstHitX = xComp;
					FirstHitY = yComp;

					// выбираем направление для стрельбы в режиме AI
					if (!dirs.empty())
					{
						dir = dirs[dirs.size() - 1];
						dirs.pop_back();
					}
					// Вывод попадания/ранения на экран
					Meny(Comp_hit_target); 
					Sleep(500); //небольшая пауза
				}
			}
				//если было попадание компьютер работает в режимt AI (mode_comp == 1) 
				else if (mode_comp == 1)
				{
					// флаг для отслеживания направления движения стрельбы
					// нужно ли менять направление 
					// если дошли до одной из границ поля
					bool changeDir = 0;
					if (dir == 0) // движение влево
					{
						if (xComp > 2) xComp -= 2;
						else changeDir = 1;
					}
					else if (dir == 1) // движение вправо
					{
						if (xComp < 55) xComp += 2;
						else changeDir = 1;
					}
					else if (dir == 2) // движение вверх
					{
						if (y > 2) yComp--;
						else changeDir = 1;
					}
					else if (dir == 3) // движение вниз
					{
						if (y < 11) yComp++;
						else changeDir = 1;
					}

					if (changeDir)
					{
						if (!dirs.empty())
						{
							dir = dirs[dirs.size() - 1];
							dirs.pop_back();
						}

						xComp = FirstHitX;
						yComp = FirstHitY;
						continue;
					}

					result_shot = explosion(mask_pos,ship_pos, yComp, xComp, ships, win_comp);
					if (win_comp) break;
					//проверяем позицию по которой мы выстрельнули на наличие корабликов
					//уже в режиме mode=1 (AI)
					if (result_shot == 1)
					{
						/// Вывод попадания/ранения на экран
						Meny(Comp_hit_target); //вывод реплики на экран
						Sleep(500); //небольшая пауза
					}
					else if (result_shot == 2)
					{
						// Вывод уничтожения корабля на экран
						Meny(Comp_ship_explosion); //вывод реплики на экран
						Sleep(500); //небольшая пауза
						// после потопления корабля возврашяем режим стрельбы в случайный
						mode_comp = 0;
						// заново инициализируем вектор направлений
						dirs.clear();
						dirs.push_back(3);
						dirs.push_back(2);
						dirs.push_back(1);
						dirs.push_back(0);
						//перемешиваем случайным образом направления в векторе
						random_shuffle(dirs.begin(), dirs.end());
					}
					//если промах при стрельбе в режиме mode=1
					else (result_shot == 0);
					{
						if (!dirs.empty())
						{
							dir = dirs[dirs.size() - 1];
							dirs.pop_back();
						}

						xComp = FirstHitX;
						yComp = FirstHitY;
					}
					
					//вывод промаха на экран
					Meny(Comp_missed);
					Sleep(500);
					//очередь атаки противника
					Meny(you_move);
					//очередь атаки игрока
					your_turn = !your_turn;
				}
		}
	} while (win_human ==false && win_comp == false);

	PaintPos(ship_pos, 2, 0);
	PaintPos(comp_ship_pos, 37, 15); //перерисовываем игровую локации с учетём внесенных изменений (поставили кораблик)
	
	// если победа человека
	if (win_human)
		Meny(you_win);
	else
	// если победа компьютера
		Meny(Comp_win);
}